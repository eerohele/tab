(require '[cognitect.transcriptor :as xr])

(require '[clojure.pprint :as cpp])
(require '[clojure.spec.alpha :as spec])
(require '[clojure.test.check :refer [quick-check]])
(require '[clojure.test.check.generators :as gen])
(require '[clojure.test.check.properties :refer [for-all]])

(require '[tab.impl.pprint :as pp])

(spec/def ::pass? true?)
(spec/def ::ret (spec/keys :req-un [::pass?]))

(set! *print-length* nil)
(set! *print-level* nil)

;; Prints readably
(quick-check 10000
  (for-all [x gen/any-printable-equatable]
    (= x (read-string (with-out-str (pp/pprint x))))))

(xr/check! ::ret)

;; With infinite max width, prints everything the same way as prn.
(quick-check 10000
  (for-all [x gen/any-printable-equatable]
    (=
      (with-out-str (pp/pprint x {:max-width ##Inf}))
      (with-out-str (prn x)))))

(xr/check! ::ret)

;; TODO: Generative test that checks that nothing gets printed past
;; :max-width except strings? Not sure how easy it is to check whether
;; the thing past max-width is within a string, though.

(quick-check 1000
  (for-all [print-level gen/nat
            print-length gen/nat
            x (gen/vector gen/int)]
    (binding [*print-level* print-level
              *print-length* print-length]
      (= (with-out-str (pp/pprint x)) (with-out-str (cpp/pprint x))))))

(xr/check! ::ret)

;; Prints basic maps the same way as clojure.pprint/pprint.
(quick-check 1000
  (for-all [print-length gen/nat
            print-level gen/nat
            x (gen/map gen/keyword gen/int)]
    (binding [*print-level* print-level
              *print-length* print-length]
      (= (with-out-str (pp/pprint x)) (with-out-str (cpp/pprint x))))))

(xr/check! ::ret)

(quick-check 1000
  (for-all [print-length gen/nat
            print-level gen/nat
            print-namespace-maps gen/boolean
            x (gen/map gen/keyword-ns gen/int)]
    (binding [*print-level* print-level
              *print-length* print-length
              *print-namespace-maps* print-namespace-maps]
      (= (with-out-str (pp/pprint x)) (with-out-str (cpp/pprint x))))))

(xr/check! ::ret)

(quick-check 75
  (for-all [print-namespace-maps gen/boolean
            x (gen/map (gen/one-of [gen/keyword-ns gen/symbol-ns])
                gen/any-printable-equatable)]
    (binding [*print-namespace-maps* print-namespace-maps]
      (=
        (with-out-str
          (pp/pprint x {:max-width ##Inf}))
        (with-out-str
          (binding [cpp/*print-right-margin* ##Inf]
            (cpp/pprint x)))))))

(xr/check! ::ret)

;; A generative test that checks that pp/print and cpp/print print any
;; gen/any-printable-equatable the same way would be great, but
;; cpp/print sometimes prints things in miser mode even when there's
;; enough space to use linear mode, and I don't want to have my impl do
;; that.
;;
;; With infinite max width, however, tab.impl.pprint prints everything
;; the same way as clojure.pprint.
(quick-check 1000
  (for-all [x gen/any-printable-equatable]
    (binding [cpp/*print-right-margin* ##Inf]
      (=
        (with-out-str (pp/pprint x {:max-width ##Inf}))
        (with-out-str (cpp/pprint x))))))

(xr/check! ::ret)

;; *print-readably*
(quick-check 1000
  (for-all [x (gen/one-of [gen/string (gen/vector gen/char)])
            print-readably gen/boolean]
    (binding [*print-readably* print-readably]
      (=
        (with-out-str (pp/pprint x))
        (with-out-str (cpp/pprint x))))))

(xr/check! ::ret)

(require '[clojure.repl :as repl])

(def clojure-core-sources
  (eduction
    (map val)
    (map symbol)
    (keep
      (fn [sym]
        (try
          (repl/source-fn sym)
          (catch RuntimeException _))))
    (map (fn [s]
           (binding [*ns* (find-ns 'clojure.core)]
             (read-string {:read-cond :preserve} s))))
    (ns-interns 'clojure.core)))

(def differences
  (remove
    #(= (with-out-str (cpp/pprint %)) (with-out-str (pp/pprint %)))
    clojure-core-sources))

(count differences)

;; There are at most 25 differences between how clojure.pprint and SUT
;; print clojure.core sources.
;;
;; Haven't gone through all of them yet, but the many of them seem to be
;; cases where clojure.pprint exceeds *print-right-margin* even though
;; it doesn't have to.
(xr/check! (partial >= 25))

(comment
  ;; Spit a command to diff clojure.pprint and tab.impl.pprint output
  (do
    (require '[clojure.java.io :as io])

    (let [tmpdir (io/file (System/getProperty "java.io.tmpdir") "tab")
          cpp-file (io/file tmpdir "cpp.clj")
          pp-file (io/file tmpdir "pp.clj")]

      (.mkdirs tmpdir)

      (when (.exists cpp-file) (.delete cpp-file))
      (when (.exists pp-file) (.delete pp-file))

      (run!
        (fn [source]
          (let [cpp-source (with-out-str (cpp/pprint source))
                pp-source (with-out-str (pp/pprint source))]
            (when (not= cpp-source pp-source)
              (spit cpp-file cpp-source :append true)
              (spit pp-file pp-source :append true))))
        clojure-core-sources)

      (printf "diff -u %s %s | diff-so-fancy\n" cpp-file pp-file)))
  ,,,)

;; Benchmarks

;; Fipp

(require '[fipp.edn :as fipp])

(import '(java.io Writer))

(def null-writer (Writer/nullWriter))

(require '[criterium.core :refer [quick-bench]])

;; Numbers
(def numbers (vec (range 10000)))

'clojure.pprint/pprint
(quick-bench
  (cpp/pprint numbers null-writer))

'fipp.edn/pprint
(quick-bench
  (binding [*out* null-writer] (fipp/pprint numbers {:width 72})))

'tutkain.impl.pprint/pprint
(quick-bench
  (pp/pprint null-writer numbers {:max-width 72}))

;; Code
(require '[clojure.java.io :as io])
(import '(clojure.lang LineNumberingPushbackReader))

(def code
  (with-open [reader (->
                       "fipp/engine.cljc"
                       io/resource
                       io/reader
                       LineNumberingPushbackReader.)]
    (doall
      (take-while #(not= ::EOF %)
        (repeatedly #(read {:read-cond :allow :eof ::EOF} reader))))))

'clojure.pprint/pprint
(quick-bench
  (cpp/pprint code null-writer))

'fipp.edn/pprint
(quick-bench
  (binding [*out* null-writer] (fipp/pprint code {:width 72})))

'tutkain.impl.pprint/pprint
(quick-bench
  (pp/pprint null-writer code {:max-width 72}))

;; Generative
(def forms (gen/sample gen/any-printable-equatable 1e3))

(quick-bench
  (cpp/pprint forms null-writer))

(quick-bench
  (binding [*out* null-writer] (fipp/pprint forms {:width 72})))

(quick-bench
  (pp/pprint null-writer forms {:max-width 72}))

;; Analyzer
(require '[clojure.tools.analyzer.jvm :as analyzer])

(def analyzer-output
  (analyzer/analyze
    '(sequence
       (comp (filter odd?) (map inc) (partition-by even?))
       (range 10))))

(quick-bench
  (cpp/pprint analyzer-output null-writer))

(quick-bench
  (binding [*out* null-writer] (fipp/pprint analyzer-output {:width 72})))

(quick-bench
  (pp/pprint null-writer analyzer-output {:max-width 72}))

;; Allocated bytes

(import '(java.text StringCharacterIterator))
(import '(java.lang.management ManagementFactory))
(import '(com.sun.management ThreadMXBean))

(defn human-readable-byte-count
  [bytes]
  (if (< -1000 bytes 1000)
    (str bytes " B")
    (let [ci (StringCharacterIterator. "kMGTPE")
          bytes (loop [bytes bytes]
                  (if (or (<= bytes -999950) (>= bytes 999950))
                    (do (.next ci) (recur (/ bytes 1000)))
                    bytes))]
      (format "%.1f %cB" (/ bytes 1000.0) (.current ci)))))

(defmacro allocated-bytes
  [& body]
  `(let [^ThreadMXBean bean# (ManagementFactory/getThreadMXBean)
         bytes-before# (.getCurrentThreadAllocatedBytes bean#)]
     ~@body
     (let [bytes-after# (.getCurrentThreadAllocatedBytes bean#)]
       (println
         (human-readable-byte-count (- bytes-after# bytes-before#))
         "allocated"))))

(allocated-bytes
  (cpp/pprint analyzer-output null-writer))

(allocated-bytes
  (binding [*out* null-writer] (fipp/pprint analyzer-output {:width 72})))

(allocated-bytes
  (pp/pprint null-writer analyzer-output {:max-width 72}))
